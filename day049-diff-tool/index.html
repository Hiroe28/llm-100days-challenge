<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- OGP (Open Graph Protocol) -->
  <meta property="og:title" content="差分表示ツール - コードや文書の変更を視覚的に比較" />
  <meta property="og:description" content="ドラッグ＆ドロップでファイルを読み込み、追加・削除された部分を色分け表示。ミニマップで全体の差分を俯瞰でき、快適なナビゲーションを実現する高機能な差分比較ツール。" />
  <meta property="og:image" content="https://hiroe28.github.io/llm-100days-challenge/day049-diff-tool/screenshot.png" />
  <meta property="og:url" content="https://hiroe28.github.io/llm-100days-challenge/day049-diff-tool/index.html" />
  <meta property="og:type" content="website" />
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="差分表示ツール" />
  <meta name="twitter:description" content="ドラッグ＆ドロップでファイルを読み込み、追加・削除された部分を色分け表示。ミニマップナビゲーションと豊富なカスタマイズ機能を備えた高機能差分比較ツール。" />
  <meta name="twitter:image" content="https://hiroe28.github.io/llm-100days-challenge/day049-diff-tool/screenshot.png" />


  <title>差分表示ツール</title>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3201351704984910"
          crossorigin="anonymous"></script>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-H1SW0RH6CK"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-H1SW0RH6CK');
  </script>
    

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/search/search.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/search/searchcursor.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/dialog/dialog.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/scroll/annotatescrollbar.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/scroll/simplescrollbars.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/search/match-highlighter.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/selection/active-line.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/foldcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/foldgutter.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/brace-fold.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/comment-fold.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/indent-fold.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/display/placeholder.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/xml/xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/css/css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/htmlmixed/htmlmixed.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/comment/comment.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.18.12/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/merge/merge.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/scroll/simplescrollbars.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/fold/foldgutter.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/dialog/dialog.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/dracula.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/material.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/solarized.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/merge/merge.min.css">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      height: 100%;
      overflow: hidden;
    }
    
    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100%;
      overflow: hidden;
    }
    
    .header {
      background-color: #f0f0f0;
      padding: 10px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    
    h1 {
      margin: 0;
      font-size: 1.5rem;
      color: #333;
    }
    
    .toolbar {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      background-color: #f8f8f8;
      padding: 5px 10px;
      border-bottom: 1px solid #ddd;
      flex-shrink: 0;
    }
    
    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 5px;
      border-right: 1px solid #ddd;
      padding-right: 10px;
      margin-right: 5px;
    }
    
    .toolbar-group:last-child {
      border-right: none;
    }
    
    select, button, input {
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background-color: white;
      font-size: 14px;
    }
    
    button {
      cursor: pointer;
      background-color: #4a86e8;
      color: white;
      border: none;
      min-width: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: #3a76d8;
    }
    
    button.icon-button {
      width: 30px;
      height: 30px;
      min-width: 30px;
      padding: 0;
      border-radius: 3px;
      background-color: #f0f0f0;
      color: #333;
      border: 1px solid #ccc;
      transition: all 0.2s;
    }
    
    button.icon-button:hover {
      background-color: #e0e0e0;
    }
    
    button.icon-button.active {
      background-color: #4a86e8;
      color: white;
      border-color: #3a76d8;
    }
    
    .file-input-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .file-drop-area {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 10px;
      text-align: center;
      background-color: #f9f9f9;
      cursor: pointer;
      transition: all 0.3s;
      flex: 1;
    }
    
    .file-drop-area:hover, .file-drop-area.dragging {
      background-color: #e9e9e9;
      border-color: #4a86e8;
    }
    
    /* メインコンテンツエリア */
    .main-content {
      flex: 1;
      display: flex;
      overflow: hidden;
      position: relative;
    }
    
    /* ミニマップ */
    .diff-minimap {
      width: 30px; /* 幅を広げてマーカーを見やすく */
      height: 100%;
      background-color: #f5f5f5;
      border-right: 1px solid #ddd;
      overflow: hidden;
      position: relative;
      flex-shrink: 0;
      order: 1;
      cursor: pointer;
    }
    
    .minimap-marker {
      position: absolute;
      left: 0;
      width: 100%;
      background-color: rgba(76, 175, 80, 0.7);
      border-left: 3px solid #4caf50;
      box-sizing: border-box;
      transition: background-color 0.2s;
      z-index: 2;
      pointer-events: auto;
    }
    
    .minimap-marker.addition {
      background-color: rgba(76, 175, 80, 0.7);
      border-left: 3px solid #4caf50;
    }
    
    .minimap-marker.deletion {
      background-color: rgba(244, 67, 54, 0.7);
      border-left: 3px solid #f44336;
    }
    
    .minimap-marker:hover {
      background-color: rgba(76, 175, 80, 0.9);
    }
    
    .minimap-marker.deletion:hover {
      background-color: rgba(244, 67, 54, 0.9);
    }
    
    .minimap-marker.active {
      box-shadow: 0 0 0 3px #ffeb3b;
      z-index: 3;
    }
    
    .minimap-viewport {
      position: absolute;
      left: 0;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.6);
      box-sizing: border-box;
      cursor: grab;
      z-index: 3;
    }
    
    .minimap-viewport:active {
      cursor: grabbing;
    }
    
    .merge-view-container {
      flex: 1;
      height: 100%;
      overflow: hidden;
      order: 2;
    }
    
    /* スプリッターのスタイル */
    .resizer {
      position: absolute;
      width: 8px;
      height: 100%;
      background-color: transparent;
      cursor: col-resize;
      user-select: none;
      z-index: 5;
      transition: background-color 0.2s;
    }
    
    .resizer:hover {
      background-color: rgba(74, 134, 232, 0.3);
    }
    
    .resizer.active {
      background-color: rgba(74, 134, 232, 0.5);
    }
    
    /* 設定パネル */
    .settings-panel {
      position: absolute;
      top: 50px;
      right: 10px;
      width: 300px;
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 5px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      padding: 15px;
      z-index: 10;
      display: none;
    }
    
    .settings-panel.visible {
      display: block;
    }
    
    .settings-group {
      margin-bottom: 15px;
    }
    
    .settings-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
      color: #333;
    }
    
    .settings-row {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    
    .settings-label {
      flex: 1;
      font-size: 13px;
    }
    
    .settings-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }
    
    /* CodeMirrorのスタイル調整 */
    .CodeMirror-merge {
      height: 100%;
    }
    
    .CodeMirror {
      height: 100% !important;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
    }

    .CodeMirror-scroll {
      height: 100% !important;
      min-height: 100px;
    }
    
    .CodeMirror-merge-2pane .CodeMirror-merge-pane {
      width: 47%;
      height: 100% !important;
    }
    
    .CodeMirror-merge-2pane .CodeMirror-merge-gap {
      width: 6%;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      background-color: #f5f5f5;
    }
    
    /* 差分色のカスタマイズ */
    .CodeMirror-merge-r-chunk { 
      background-color: rgba(200, 230, 201, 0.8); /* 追加（緑色） */
    }
    .CodeMirror-merge-l-chunk { 
      background-color: rgba(255, 205, 210, 0.8); /* 削除（赤色） */
    }
    
    .CodeMirror-merge-r-chunk-start { 
      border-top: 1px solid #388e3c;
    }
    .CodeMirror-merge-r-chunk-end { 
      border-bottom: 1px solid #388e3c;
    }
    
    .CodeMirror-merge-l-chunk-start { 
      border-top: 1px solid #d32f2f;
    }
    .CodeMirror-merge-l-chunk-end { 
      border-bottom: 1px solid #d32f2f;
    }
    
    .CodeMirror-merge-r-connect { 
      fill: #c8e6c9; 
      stroke: #388e3c; 
    }
    
    .CodeMirror-merge-l-connect { 
      fill: #ffcdd2; 
      stroke: #d32f2f; 
    }
    
    /* 行番号の背景色 */
    .CodeMirror-merge .CodeMirror-merge-l-deleted .CodeMirror-linenumber { 
      background-color: #ffcdd2; 
    }
    
    .CodeMirror-merge .CodeMirror-merge-r-inserted .CodeMirror-linenumber { 
      background-color: #c8e6c9; 
    }

    /* 行の折りたたみ用スタイル */
    .CodeMirror-foldmarker {
      color: blue;
      text-shadow: #b9f 1px 1px 2px, #b9f -1px -1px 2px, #b9f 1px -1px 2px, #b9f -1px 1px 2px;
      font-family: arial;
      line-height: .3;
      cursor: pointer;
    }
    
    .CodeMirror-foldgutter {
      width: 0.7em;
    }
    
    .CodeMirror-foldgutter-open,
    .CodeMirror-foldgutter-folded {
      cursor: pointer;
    }
    
    .CodeMirror-foldgutter-open:after {
      content: "▾";
    }
    
    .CodeMirror-foldgutter-folded:after {
      content: "▸";
    }
    
    /* 検索ダイアログのスタイル */
    .CodeMirror-dialog {
      background-color: #f5f5f5;
      z-index: 15;
      padding: 5px 10px;
      overflow: hidden;
      color: #333;
      font-size: 14px;
      border-bottom: 1px solid #ddd;
    }
    
    /* ステータスバー */
    .status-bar {
      background-color: #f0f0f0;
      border-top: 1px solid #ddd;
      padding: 5px 10px;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      color: #555;
      flex-shrink: 0;
    }

    /* ショートカット情報 */
    .shortcuts-info {
      background-color: #f8f8f8;
      border-top: 1px solid #ddd;
      padding: 8px 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 12px;
      color: #555;
      flex-shrink: 0;
    }
    
    .shortcut-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .shortcut-key {
      background-color: #eee;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 1px 5px;
      font-family: monospace;
    }
    
    .cursor-info {
      margin-left: 15px;
      font-size: 12px;
      color: #666;
    }

    /* ローディングスピナー */
    .spinner {
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 3px solid #3498db;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* ドラッグ&ドロップのオーバーレイ */
    .drop-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(74, 134, 232, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .drop-overlay.visible {
      opacity: 1;
    }

    /* 差分ナビゲーションのボタン強調表示 */
    .diff-nav-buttons button {
      position: relative;
    }

    .diff-nav-buttons button.disabled {
      opacity: 0.5;
      cursor: default;
    }

    .diff-nav-buttons button.disabled:hover {
      background-color: #f0f0f0;
    }

    /* 差分カウントバッジ */
    .diff-count-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background-color: #ff5722;
      color: white;
      border-radius: 50%;
      font-size: 11px;
      min-width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 2px;
      box-sizing: border-box;
    }

    /* 現在位置バッジ */
    .current-pos-badge {
      position: absolute;
      bottom: -8px;
      right: -8px;
      background-color: #4CAF50;
      color: white;
      border-radius: 3px;
      font-size: 10px;
      min-width: 20px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 3px;
      box-sizing: border-box;
    }

    /* 現在の差分強調表示 */
    .current-diff {
      outline: 3px solid #ffeb3b !important;
      z-index: 4 !important;
      box-shadow: 0 0 8px #ffeb3b !important;
      position: relative !important;
    }

    /* レスポンシブ調整 */
    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }
      
      .toolbar-group {
        flex-wrap: wrap;
        border-right: none;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
        margin-bottom: 5px;
      }
      
      .file-input-container {
        flex-direction: column;
        align-items: stretch;
      }
      
      .diff-minimap {
        width: 15px;
      }
    }
    
    /* ダークモード */
    .dark-mode {
      background-color: #1e1e1e;
      color: #e0e0e0;
    }
    
    .dark-mode .header,
    .dark-mode .toolbar,
    .dark-mode .status-bar,
    .dark-mode .shortcuts-info,
    .dark-mode .diff-summary,
    .dark-mode .diff-minimap {
      background-color: #2d2d2d;
      border-color: #444;
      color: #e0e0e0;
    }
    
    .dark-mode h1 {
      color: #e0e0e0;
    }
    
    .dark-mode button.icon-button {
      background-color: #3d3d3d;
      color: #e0e0e0;
      border-color: #555;
    }
    
    .dark-mode button.icon-button:hover {
      background-color: #4d4d4d;
    }
    
    .dark-mode .shortcut-key {
      background-color: #3d3d3d;
      color: #e0e0e0;
      border-color: #555;
    }
    
    .dark-mode .settings-panel {
      background-color: #2d2d2d;
      border-color: #444;
      color: #e0e0e0;
    }
    
    .dark-mode .settings-title {
      color: #e0e0e0;
    }
    
    .dark-mode .file-drop-area {
      background-color: #3d3d3d;
      border-color: #555;
      color: #e0e0e0;
    }
    
    .dark-mode .file-drop-area:hover,
    .dark-mode .file-drop-area.dragging {
      background-color: #4d4d4d;
      border-color: #4a86e8;
    }
    
    .dark-mode .minimap-viewport {
      background-color: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.8);
    }
    
    /* 差分サマリー（オプション機能） */
    .diff-summary {
      max-height: 120px;
      overflow-y: auto;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ddd;
      padding: 5px 10px;
      flex-shrink: 0;
    }
    
    .diff-summary-title {
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 12px;
    }
    
    .diff-item {
      display: flex;
      align-items: center;
      font-size: 12px;
      padding: 2px 5px;
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 2px;
    }
    
    .diff-item:hover {
      background-color: #e0e0e0;
    }
    
    .diff-marker {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 5px;
      flex-shrink: 0;
    }
    
    .diff-marker.deletion {
      background-color: #f44336;
    }
    
    .diff-marker.addition {
      background-color: #4caf50;
    }
    
    .diff-location {
      font-weight: bold;
      margin-right: 5px;
    }
    
    .diff-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    /* ナビゲーションのアニメーション */
    @keyframes highlight-diff {
      0% { background-color: rgba(255, 235, 59, 0.5); }
      100% { background-color: transparent; }
    }

    .highlight-diff {
      animation: highlight-diff 1.5s ease-out;
    }

    /* デバッグ用：重要なCSSクラスに色を付ける */
    .debug-highlight .CodeMirror-merge-r-chunk,
    .debug-highlight .CodeMirror-merge-l-chunk {
      outline: 2px dashed yellow;
    }

    .debug-highlight .CodeMirror-merge-r-chunk-start,
    .debug-highlight .CodeMirror-merge-l-chunk-start {
      outline: 2px dashed orange;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="drop-overlay">ファイルをドロップしてください</div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    
    // メインアプリコンポーネント
    function DiffApp() {
      // 状態の定義
      const [leftText, setLeftText] = useState('');
      const [rightText, setRightText] = useState('');
      const [language, setLanguage] = useState('javascript');
      const [indentSize, setIndentSize] = useState(2);
      const [theme, setTheme] = useState('default');
      const [fontSize, setFontSize] = useState(14);
      const [lineWrapping, setLineWrapping] = useState(false);
      const [showDiffSummary, setShowDiffSummary] = useState(false);
      const [diffCount, setDiffCount] = useState(0);
      const [leftActiveFile, setLeftActiveFile] = useState('');
      const [rightActiveFile, setRightActiveFile] = useState('');
      const [settingsVisible, setSettingsVisible] = useState(false);
      const [darkMode, setDarkMode] = useState(false);
      const [cursorPosition, setCursorPosition] = useState({ line: 0, ch: 0 });
      const [loading, setLoading] = useState(false);
      const [splitRatio, setSplitRatio] = useState(0.5);
      const [debugMode, setDebugMode] = useState(false);
      const [currentDiffIndex, setCurrentDiffIndex] = useState(-1);
      
      // refの定義
      const mergeViewRef = useRef(null);
      const mergeViewContainerRef = useRef(null);
      const minimapRef = useRef(null);
      const resizerRef = useRef(null);
      const startXRef = useRef(0);
      const startWidthRef = useRef(0);
      
      // ミニマップ操作用のref
      const minimapDraggingRef = useRef(false);
      const startScrollTopRef = useRef(0);
      const viewportOffsetRef = useRef(0);
      const docHeightRef = useRef(0);
      
      // 差分リスト保存用ref
      const diffListRef = useRef([]);
      
      // 現在の差分インデックスを保存するref
      const currentDiffIndexRef = useRef(-1);
      
      // 最後の差分解析時のテキスト保存用ref
      const lastLeftTextRef = useRef(null);
      const lastRightTextRef = useRef(null);
      
      // アニメーションフレーム ID 保存用
      const scrollAnimationFrameRef = useRef(null);
      
      // isScrollingフラグ
      const isScrollingRef = useRef(false);
      
      // ローカルストレージから設定を読み込み
      const loadSettings = useCallback(() => {
        try {
          const savedSettings = localStorage.getItem('diffToolSettings');
          if (savedSettings) {
            const settings = JSON.parse(savedSettings);
            setLanguage(settings.language || 'javascript');
            setIndentSize(parseInt(settings.indentSize) || 2);
            setTheme(settings.theme || 'default');
            setFontSize(parseInt(settings.fontSize) || 14);
            setLineWrapping(settings.lineWrapping || false);
            setDarkMode(settings.darkMode || false);
            setSplitRatio(parseFloat(settings.splitRatio) || 0.5);
            setShowDiffSummary(settings.showDiffSummary || false);
          }
        } catch (e) {
          console.error('設定の読み込みエラー:', e);
        }
      }, []);
      
      // 設定を保存
      const saveSettings = useCallback(() => {
        try {
          const settings = {
            language,
            indentSize,
            theme,
            fontSize,
            lineWrapping,
            darkMode,
            splitRatio,
            showDiffSummary
          };
          localStorage.setItem('diffToolSettings', JSON.stringify(settings));
        } catch (e) {
          console.error('設定の保存エラー:', e);
        }
      }, [language, indentSize, theme, fontSize, lineWrapping, darkMode, splitRatio, showDiffSummary]);
      
      // ダークモードの適用
      useEffect(() => {
        if (darkMode) {
          document.body.classList.add('dark-mode');
        } else {
          document.body.classList.remove('dark-mode');
        }
      }, [darkMode]);
      
      // 初期ロード時に設定を読み込む
      useEffect(() => {
        loadSettings();
      }, [loadSettings]);
      
      // 設定変更時に保存
      useEffect(() => {
        saveSettings();
      }, [saveSettings]);
      
      // 現在のdiffIndexをrefに反映
      useEffect(() => {
        currentDiffIndexRef.current = currentDiffIndex;
      }, [currentDiffIndex]);
      
      // ファイルサイズに基づいて最適なビューポートマージンを計算
      const calculateViewportMargin = useCallback(() => {
        // 常にすべての行を描画（ミニマップで差分を表示するため）
        return Infinity;
      }, []);
      
      // 以前の差分強調表示をクリアする
      const clearCurrentDiffHighlight = useCallback(() => {
        if (!mergeViewRef.current) return;
        
        const leftEditor = mergeViewRef.current.leftOriginal();
        const rightEditor = mergeViewRef.current.editor();
        
        if (leftEditor) {
          const leftWrapper = leftEditor.getWrapperElement();
          const leftHighlighted = leftWrapper.querySelectorAll('.current-diff');
          leftHighlighted.forEach(el => el.classList.remove('current-diff'));
        }
        
        if (rightEditor) {
          const rightWrapper = rightEditor.getWrapperElement();
          const rightHighlighted = rightWrapper.querySelectorAll('.current-diff');
          rightHighlighted.forEach(el => el.classList.remove('current-diff'));
        }
      }, []);
      
      // 現在の差分をハイライト表示する
      const highlightCurrentDiff = useCallback((diffInfo) => {
        if (!mergeViewRef.current) return;
        
        const editor = diffInfo.side === 'left' 
          ? mergeViewRef.current.leftOriginal() 
          : mergeViewRef.current.editor();
        
        const element = editor.getWrapperElement();
        
        // 以前の強調表示をクリア
        clearCurrentDiffHighlight();
        
        // ブロックの全要素を強調表示する場合
        if (diffInfo.elements && diffInfo.elements.length > 0) {
          // ブロックに属するすべての要素を強調
          diffInfo.elements.forEach(el => {
            el.classList.add('current-diff');
          });
          
          // 最初の要素にハイライト効果
          const firstElement = diffInfo.elements[0];
          firstElement.classList.add('highlight-diff');
          
          // 一定時間後にハイライト効果を削除（強調表示は残す）
          setTimeout(() => {
            firstElement.classList.remove('highlight-diff');
          }, 1500);
          
          return;
        }
        
        // 既存の方法でチャンクを探す（後方互換性）
        // diffInfo.startLineに最も近い差分チャンクを探す
        const allChunks = element.querySelectorAll(
          diffInfo.side === 'left' 
            ? '.CodeMirror-merge-l-chunk, .CodeMirror-merge-l-deleted'
            : '.CodeMirror-merge-r-chunk, .CodeMirror-merge-r-inserted'
        );
        
        let closestChunk = null;
        let minDistance = Infinity;
        
        Array.from(allChunks).forEach(chunk => {
          // チャンクの行番号を取得
          let chunkLine;
          if (chunk.dataset && chunk.dataset.line) {
            chunkLine = parseInt(chunk.dataset.line, 10);
          } else {
            try {
              const chunkRect = chunk.getBoundingClientRect();
              const editorRect = element.getBoundingClientRect();
              const startY = chunkRect.top - editorRect.top + editor.getScrollInfo().top;
              chunkLine = editor.lineAtHeight(startY, 'local');
            } catch (e) {
              console.error('行番号取得エラー:', e);
              return;
            }
          }
          
          // 目的の行との距離を計算
          const distance = Math.abs(chunkLine - diffInfo.startLine);
          
          if (distance < minDistance) {
            minDistance = distance;
            closestChunk = chunk;
          }
        });
        
        // 最も近いチャンクがあれば強調表示
        if (closestChunk) {
          closestChunk.classList.add('current-diff');
          
          // ハイライト効果も追加
          closestChunk.classList.add('highlight-diff');
          
          // 一定時間後にハイライト効果を削除（強調表示は残す）
          setTimeout(() => {
            closestChunk.classList.remove('highlight-diff');
          }, 1500);
          
          // 行が表示されているかを確認
          const line = editor.getLine(diffInfo.startLine);
          if (!line) {
            console.warn(`行 ${diffInfo.startLine} は存在しません`);
          }
        } else {
          console.warn('強調表示する差分チャンクが見つかりませんでした:', {
            側: diffInfo.side,
            行: diffInfo.startLine,
            チャンク数: allChunks.length
          });
          
          // 代替手段: 行全体を強調表示
          const linePos = {line: diffInfo.startLine, ch: 0};
          const lineEndPos = {line: diffInfo.startLine, ch: editor.getLine(diffInfo.startLine)?.length || 0};
          
          editor.markText(linePos, lineEndPos, {
            className: 'current-diff',
            clearOnEnter: false
          });
          
          // フォールバック: テキストマーカーを使用
          editor.addLineClass(diffInfo.startLine, 'background', 'current-diff');
        }
      }, [clearCurrentDiffHighlight]);
      
      // 共通の差分ジャンプ関数
      const jumpToDiff = useCallback((diffInfo) => {
        if (!mergeViewRef.current) return;
        
        // 以前の強調表示をクリア
        clearCurrentDiffHighlight();
        
        const editor = diffInfo.side === 'left' 
          ? mergeViewRef.current.leftOriginal() 
          : mergeViewRef.current.editor();
        
        if (!editor) return;
        
        // 順序が重要: 先にカーソル設定→後でスクロール
        
        // 1. まずカーソルを目標位置に設定
        editor.setCursor({line: diffInfo.startLine, ch: 0});
        
        // 2. CodeMirrorの内部スクロールが完了するのを待ってから
        // 明示的な位置指定でスクロール位置を上書き
        setTimeout(() => {
          // 行の座標を取得して適切な位置を計算
          const coords = editor.charCoords({line: diffInfo.startLine, ch: 0}, 'local');
          const scrollPos = Math.max(0, coords.top - 50);
          
          // スクロールフラグを設定
          isScrollingRef.current = true;
          
          // 両方のエディタを同期
          if (diffInfo.side === 'left') {
            const rightEditor = mergeViewRef.current.editor();
            // 先に左側を設定
            editor.scrollTo(null, scrollPos);
            // 次に右側を設定
            rightEditor.scrollTo(null, scrollPos);
          } else {
            const leftEditor = mergeViewRef.current.leftOriginal();
            // 先に右側を設定
            editor.scrollTo(null, scrollPos);
            // 次に左側を設定
            leftEditor.scrollTo(null, scrollPos);
          }
          
          // 差分要素を強調表示
          highlightCurrentDiff(diffInfo);
          
          // スクロール完了後にフラグをリセット
          setTimeout(() => {
            isScrollingRef.current = false;
          }, 100);
        }, 50);
      }, [clearCurrentDiffHighlight, highlightCurrentDiff]);
      
      // ミニマップ上の現在の差分マーカーをハイライト
      const updateActiveMarker = useCallback((index) => {
        if (!minimapRef.current) return;
        
        // まず既存のアクティブクラスを削除
        const markers = minimapRef.current.querySelectorAll('.minimap-marker');
        markers.forEach(marker => marker.classList.remove('active'));
        
        // 新しいアクティブマーカーにクラスを追加
        if (index >= 0 && index < markers.length) {
          markers[index].classList.add('active');
        }
      }, []);
      
      // 差分ナビゲーション - 次の差分へ移動
      const gotoNextDiff = useCallback(() => {
        if (!mergeViewRef.current || diffListRef.current.length === 0) return;
        
        // 次のインデックスを計算（現在のインデックスが最後なら最初に戻る）
        let nextIndex = currentDiffIndexRef.current + 1;
        if (nextIndex >= diffListRef.current.length) {
          nextIndex = 0;
        }
        
        // 対象の差分情報を取得
        const diffInfo = diffListRef.current[nextIndex];
        if (!diffInfo) return;
        
        // 差分位置にジャンプ
        jumpToDiff(diffInfo);
        
        // 現在のインデックスを更新
        setCurrentDiffIndex(nextIndex);
        currentDiffIndexRef.current = nextIndex;
        
        // ミニマップ上でアクティブなマーカーを強調表示
        updateActiveMarker(nextIndex);
      }, [jumpToDiff, updateActiveMarker]);
      
      // 差分ナビゲーション - 前の差分へ移動
      const gotoPrevDiff = useCallback(() => {
        if (!mergeViewRef.current || diffListRef.current.length === 0) return;
        
        // 前のインデックスを計算（現在のインデックスが最初なら最後に移動）
        let prevIndex = currentDiffIndexRef.current - 1;
        if (prevIndex < 0) {
          prevIndex = diffListRef.current.length - 1;
        }
        
        // 対象の差分情報を取得
        const diffInfo = diffListRef.current[prevIndex];
        if (!diffInfo) return;
        
        // 差分位置にジャンプ
        jumpToDiff(diffInfo);
        
        // 現在のインデックスを更新
        setCurrentDiffIndex(prevIndex);
        currentDiffIndexRef.current = prevIndex;
        
        // ミニマップ上でアクティブなマーカーを強調表示
        updateActiveMarker(prevIndex);
      }, [jumpToDiff, updateActiveMarker]);
      
      // ミニマップビューポートの位置更新
      const updateViewportPosition = useCallback((scrollInfo) => {
        if (!minimapRef.current || !mergeViewRef.current) return;
        
        // 既存のビューポート要素を取得または作成
        let viewport = minimapRef.current.querySelector('.minimap-viewport');
        if (!viewport) {
          viewport = document.createElement('div');
          viewport.className = 'minimap-viewport';
          viewport.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            if (!mergeViewRef.current) return;
            
            minimapDraggingRef.current = true;
            
            // ドラッグ開始位置と現在のスクロール位置を記録
            const rightEditor = mergeViewRef.current.editor();
            startScrollTopRef.current = rightEditor.getScrollInfo().top;
            
            // クリック位置とビューポート上端の差分を計算
            const rect = e.target.getBoundingClientRect();
            viewportOffsetRef.current = e.clientY - rect.top;
            
            // マウスイベントの登録
            document.addEventListener('mousemove', handleViewportMouseMove);
            document.addEventListener('mouseup', handleViewportMouseUp);
            
            // ドラッグ中のカーソルスタイル
            document.body.style.cursor = 'grabbing';
            e.target.style.cursor = 'grabbing';
          });
          minimapRef.current.appendChild(viewport);
        }
        
        const minimapHeight = minimapRef.current.clientHeight;
        const docHeight = docHeightRef.current;
        
        if (docHeight <= 0) return;
        
        // ビューポートの高さと位置の計算
        const viewportHeight = Math.max(20, (scrollInfo.clientHeight / docHeight) * minimapHeight);
        const maxScrollTop = docHeight - scrollInfo.clientHeight;
        
        // スクロール可能な場合のみ位置を更新
        if (maxScrollTop > 0) {
          const scrollRatio = scrollInfo.top / maxScrollTop;
          const viewportTop = scrollRatio * (minimapHeight - viewportHeight);
          viewport.style.top = `${viewportTop}px`;
          viewport.style.height = `${viewportHeight}px`;
          viewport.style.opacity = '1';
        } else {
          // スクロールが不要な場合
          viewport.style.top = '0';
          viewport.style.height = `${minimapHeight}px`;
          viewport.style.opacity = '0.4';
        }
      }, []);
      
      // ビューポートドラッグ時のマウス移動
      const handleViewportMouseMove = useCallback((e) => {
        if (!minimapDraggingRef.current || !minimapRef.current || !mergeViewRef.current) return;
        
        e.preventDefault();
        
        const minimapRect = minimapRef.current.getBoundingClientRect();
        const minimapHeight = minimapRect.height;
        
        // ミニマップ範囲内でのマウス位置
        const posY = Math.max(0, Math.min(e.clientY - minimapRect.top - viewportOffsetRef.current, minimapHeight));
        
        // スクロール位置の計算
        const docHeight = docHeightRef.current;
        const rightEditor = mergeViewRef.current.editor();
        const leftEditor = mergeViewRef.current.leftOriginal();
        
        if (docHeight > 0) {
          const scrollInfo = rightEditor.getScrollInfo();
          const clientHeight = scrollInfo.clientHeight;
          const maxScroll = docHeight - clientHeight;
          
          if (maxScroll > 0) {
            // ビューポートの高さを考慮したスクロール位置計算
            const viewportHeight = (clientHeight / docHeight) * minimapHeight;
            const maxPosY = minimapHeight - viewportHeight;
            const scrollRatio = Math.max(0, Math.min(1, posY / maxPosY));
            const newScrollTop = scrollRatio * maxScroll;
            
            // スクロールフラグを設定
            isScrollingRef.current = true;
            
            // 両方のエディタをスクロール
            rightEditor.scrollTo(null, newScrollTop);
            leftEditor.scrollTo(null, newScrollTop);
          }
        }
      }, []);
      
      // ビューポートのマウスアップイベント
      const handleViewportMouseUp = useCallback(() => {
        minimapDraggingRef.current = false;
        document.body.style.cursor = '';
        
        document.removeEventListener('mousemove', handleViewportMouseMove);
        document.removeEventListener('mouseup', handleViewportMouseUp);
        
        // スクロールフラグをリセット
        setTimeout(() => {
          isScrollingRef.current = false;
        }, 100);
      }, [handleViewportMouseMove]);
      
      // ミニマップクリック時のスクロール
      const handleMinimapClick = useCallback((e) => {
        // ビューポート自体のクリックは無視
        if (e.target.classList.contains('minimap-viewport') || 
            e.target.classList.contains('minimap-marker')) {
          return;
        }
        
        if (!minimapRef.current || !mergeViewRef.current) return;
        
        const rect = minimapRef.current.getBoundingClientRect();
        const clickRatio = (e.clientY - rect.top) / rect.height;
        
        const rightEditor = mergeViewRef.current.editor();
        const leftEditor = mergeViewRef.current.leftOriginal();
        const scrollInfo = rightEditor.getScrollInfo();
        
        // ドキュメント全体の高さを取得
        const docHeight = docHeightRef.current;
        const maxScroll = docHeight - scrollInfo.clientHeight;
        
        if (maxScroll > 0) {
          // スクロールフラグを設定
          isScrollingRef.current = true;
          
          const newScrollTop = clickRatio * maxScroll;
          rightEditor.scrollTo(null, newScrollTop);
          leftEditor.scrollTo(null, newScrollTop);
          
          // スクロール完了後にフラグをリセット
          setTimeout(() => {
            isScrollingRef.current = false;
          }, 100);
        }
      }, []);
      
      // ミニマップでのホイールスクロール
      const handleMinimapWheel = useCallback((e) => {
        e.preventDefault();
        
        if (!mergeViewRef.current) return;
        
        const rightEditor = mergeViewRef.current.editor();
        const leftEditor = mergeViewRef.current.leftOriginal();
        const scrollInfo = rightEditor.getScrollInfo();
        
        // スクロール量を調整
        const delta = e.deltaY * 2;
        const newScrollTop = Math.max(0, Math.min(scrollInfo.top + delta, scrollInfo.height - scrollInfo.clientHeight));
        
        // スクロールフラグを設定
        isScrollingRef.current = true;
        
        rightEditor.scrollTo(null, newScrollTop);
        leftEditor.scrollTo(null, newScrollTop);
        
        // スクロール完了後にフラグをリセット
        setTimeout(() => {
          isScrollingRef.current = false;
        }, 100);
      }, []);
      
      // push to left/rightボタンクリック時にスクロール位置を保持する関数 + ツールチップ修正
      const fixCopyScroll = useCallback(() => {
        if (!mergeViewContainerRef.current) return;
        
        const gap = mergeViewContainerRef.current.querySelector('.CodeMirror-merge-gap');
        if (!gap) return;
        
        // // ツールチップ修正のためのヘルパー関数 - 重複を避けるため1つだけに統一
        // const applyCopyTooltip = (btn) => {
        //   btn.title = btn.classList.contains('CodeMirror-merge-copy-reverse')
        //     ? '左にコピー' // ← 矢印なので左側へコピー
        //     : '右にコピー'; // → 矢印なので右側へコピー
        // };
        
        // 既存のボタンにツールチップを適用
        // Array.from(gap.querySelectorAll('.CodeMirror-merge-copy')).forEach(applyCopyTooltip);
        
        // // 今後生成されるボタンのためにイベントデリゲーション - 重複を避けるため既存リスナーを削除
        // gap.removeEventListener('mouseover', function handleMouseOver(e) {
        //   if (e.target.classList && e.target.classList.contains('CodeMirror-merge-copy')) {
        //     applyCopyTooltip(e.target);
        //   }
        // });
        
        // 新しいイベントリスナーを登録
        gap.addEventListener('mouseover', (e) => {
          if (e.target.classList && e.target.classList.contains('CodeMirror-merge-copy')) {
            applyCopyTooltip(e.target);
          }
        });
        
        // スクロール位置保持の処理
        gap.addEventListener('click', e => {
          // コピーボタンのクリックのみ処理
          if (!e.target.classList.contains('CodeMirror-merge-copy')) return;
          
          // クリック前のスクロール位置を保存
          const left = mergeViewRef.current.leftOriginal();
          const right = mergeViewRef.current.editor();
          const leftTop = left.getScrollInfo().top;
          const rightTop = right.getScrollInfo().top;
          
          // コピー処理後（次のイベントループで）スクロール位置を元に戻す
          setTimeout(() => {
            left.scrollTo(null, leftTop);
            right.scrollTo(null, rightTop);
          }, 0);
        });
      }, []);
      
      // ミニマップ差分マーカーを作成する関数 - 重複を避けて1つの実装に統一
      const createMinimapMarkers = useCallback(() => {
        if (!minimapRef.current || !mergeViewRef.current) return;

        const leftEditor = mergeViewRef.current.leftOriginal();
        const rightEditor = mergeViewRef.current.editor();
        
        if (!leftEditor || !rightEditor) return;
        
        const currentLeftText = leftEditor.getValue();
        const currentRightText = rightEditor.getValue();
        
        // スクロール中、かつテキストが変わっていない場合はビューポート位置の更新のみ
        if (isScrollingRef.current && 
            currentLeftText === lastLeftTextRef.current && 
            currentRightText === lastRightTextRef.current) {
          updateViewportPosition(rightEditor.getScrollInfo());
          return;
        }
        
        // 現在のテキストを保存
        lastLeftTextRef.current = currentLeftText;
        lastRightTextRef.current = currentRightText;

        const minimapContainer = minimapRef.current;
        // マーカーだけクリア
        Array.from(minimapContainer.querySelectorAll('.minimap-marker')).forEach(el => el.remove());

        const minimapHeight = minimapContainer.clientHeight;
        
        // 左側のエディタ
        const leftWrapperElement = leftEditor.getWrapperElement();
        
        // 右側のエディタ
        const rightWrapperElement = rightEditor.getWrapperElement();
        
        // 差分チャンクを取得 - 修正: 代表要素だけを選択
        const leftChunks = Array.from(leftWrapperElement.querySelectorAll(
          '.CodeMirror-merge-l-chunk-start, .CodeMirror-merge-l-deleted'
        ));
        
        const rightChunks = Array.from(rightWrapperElement.querySelectorAll(
          '.CodeMirror-merge-r-chunk-start, .CodeMirror-merge-r-inserted'
        ));
        
        // 文書の高さを取得
        const leftHeight = leftEditor.getScrollInfo().height;
        const rightHeight = rightEditor.getScrollInfo().height;
        const docHeight = Math.max(leftHeight, rightHeight);
        docHeightRef.current = docHeight;
        
        // 差分情報の配列
        const diffList = [];
        
        // 差分チャンクに行番号データ属性を追加（ジャンプ時の特定用）
        const addLineNumbersToChunks = (chunks, editor) => {
          chunks.forEach(chunk => {
            const chunkRect = chunk.getBoundingClientRect();
            const editorRect = editor.getWrapperElement().getBoundingClientRect();
            const startY = chunkRect.top - editorRect.top + editor.getScrollInfo().top;
            const startLine = editor.lineAtHeight(startY, 'local');
            chunk.dataset.line = startLine;
          });
        };
        
        // チャンクに行番号を追加
        addLineNumbersToChunks(leftChunks, leftEditor);
        addLineNumbersToChunks(rightChunks, rightEditor);
        
        // 行番号で重複排除するための集合
        const leftLinesSeen = new Set();
        const rightLinesSeen = new Set();
        
        // 左側の差分を処理（行番号で重複排除）
        leftChunks.forEach(chunk => {
          try {
            // 差分チャンクの位置情報
            const chunkRect = chunk.getBoundingClientRect();
            const editorRect = leftWrapperElement.getBoundingClientRect();
            
            // エディタ内での相対位置を計算
            const startY = chunkRect.top - editorRect.top + leftEditor.getScrollInfo().top;
            const endY = chunkRect.bottom - editorRect.top + leftEditor.getScrollInfo().top;
            
            // 行番号を取得
            const startLine = leftEditor.lineAtHeight(startY, 'local');
            const endLine = leftEditor.lineAtHeight(endY, 'local');
            
            // 行番号による重複チェック - 同じ行の差分は処理しない
            if (leftLinesSeen.has(startLine)) return;
            leftLinesSeen.add(startLine);
            
            // ミニマップ上の位置を計算
            const topPercent = startY / docHeight;
            const heightPercent = (endY - startY) / docHeight;
            
            const markerTop = topPercent * minimapHeight;
            const markerHeight = Math.max(3, heightPercent * minimapHeight);
            
            // 差分情報を保存
            diffList.push({
              side: 'left',
              startY,
              endY,
              startLine,
              endLine,
              markerTop,
              markerHeight,
              chunk: chunk
            });
            
            // マーカーを作成
            const marker = document.createElement('div');
            marker.className = 'minimap-marker deletion';
            marker.style.top = `${markerTop}px`;
            marker.style.height = `${markerHeight}px`;
            marker.dataset.side = 'left';
            marker.dataset.line = startLine;
            
            // クリックイベント
            marker.addEventListener('click', (e) => {
              e.stopPropagation();
              
              // この差分のインデックスを探す
              const index = diffList.findIndex(diff => 
                diff.side === 'left' && diff.startLine === startLine
              );
              
              if (index !== -1) {
                setCurrentDiffIndex(index);
                currentDiffIndexRef.current = index;
                updateActiveMarker(index);
                
                // 共通ジャンプ関数を使用
                jumpToDiff(diffList[index]);
              }
            });
            
            minimapContainer.appendChild(marker);
          } catch (e) {
            console.error('左側マーカー作成エラー:', e);
          }
        });
        
        // 右側の差分を処理（行番号で重複排除）
        rightChunks.forEach(chunk => {
          try {
            // 差分チャンクの位置情報
            const chunkRect = chunk.getBoundingClientRect();
            const editorRect = rightWrapperElement.getBoundingClientRect();
            
            // エディタ内での相対位置を計算
            const startY = chunkRect.top - editorRect.top + rightEditor.getScrollInfo().top;
            const endY = chunkRect.bottom - editorRect.top + rightEditor.getScrollInfo().top;
            
            // 行番号を取得
            const startLine = rightEditor.lineAtHeight(startY, 'local');
            const endLine = rightEditor.lineAtHeight(endY, 'local');
            
            // 行番号による重複チェック - 同じ行の差分は処理しない
            if (rightLinesSeen.has(startLine)) return;
            rightLinesSeen.add(startLine);
            
            // ミニマップ上の位置を計算
            const topPercent = startY / docHeight;
            const heightPercent = (endY - startY) / docHeight;
            
            const markerTop = topPercent * minimapHeight;
            const markerHeight = Math.max(3, heightPercent * minimapHeight);
            
            // 差分情報を保存
            diffList.push({
              side: 'right',
              startY,
              endY,
              startLine,
              endLine,
              markerTop,
              markerHeight,
              chunk: chunk
            });
            
            // マーカーを作成
            const marker = document.createElement('div');
            marker.className = 'minimap-marker addition';
            marker.style.top = `${markerTop}px`;
            marker.style.height = `${markerHeight}px`;
            marker.dataset.side = 'right';
            marker.dataset.line = startLine;
            
            // クリックイベント
            marker.addEventListener('click', (e) => {
              e.stopPropagation();
              
              // この差分のインデックスを探す
              const index = diffList.findIndex(diff => 
                diff.side === 'right' && diff.startLine === startLine
              );
              
              if (index !== -1) {
                setCurrentDiffIndex(index);
                currentDiffIndexRef.current = index;
                updateActiveMarker(index);
                
                // 共通ジャンプ関数を使用
                jumpToDiff(diffList[index]);
              }
            });
            
            minimapContainer.appendChild(marker);
          } catch (e) {
            console.error('右側マーカー作成エラー:', e);
          }
        });
        
        // Y座標で差分をソート（上から下へ）
        diffList.sort((a, b) => a.markerTop - b.markerTop);
        
        // 差分リストをrefに保存
        diffListRef.current = diffList;
        
        // 正確な差分数をセット - 単純に diffList.length を使用（行比較fallbackを削除）
        setDiffCount(diffList.length);
        
        // 差分がある場合、現在のインデックスを0に設定（最初の差分を選択）
        if (diffList.length > 0 && currentDiffIndexRef.current === -1) {
          setCurrentDiffIndex(0);
          currentDiffIndexRef.current = 0;
          updateActiveMarker(0);
        } else if (diffList.length === 0) {
          // 差分がなくなった場合
          setCurrentDiffIndex(-1);
          currentDiffIndexRef.current = -1;
        } else if (currentDiffIndexRef.current >= diffList.length) {
          // 差分数が減少した場合、インデックスを調整
          setCurrentDiffIndex(diffList.length - 1);
          currentDiffIndexRef.current = diffList.length - 1;
          updateActiveMarker(diffList.length - 1);
        } else if (currentDiffIndexRef.current >= 0) {
          // 現在のアクティブマーカーを更新
          updateActiveMarker(currentDiffIndexRef.current);
        }
        
        // ビューポートバーの更新
        updateViewportPosition(rightEditor.getScrollInfo());
      }, [updateActiveMarker, updateViewportPosition, jumpToDiff]);
      
      // CodeMirror MergeViewの初期化
      const initMergeView = useCallback(() => {
        if (!mergeViewContainerRef.current) return;

        // 既存のMergeViewを削除
        if (mergeViewRef.current) {
          mergeViewContainerRef.current.innerHTML = '';
        }
        
        // ファイルサイズに応じたビューポートマージンを設定
        const viewportMargin = calculateViewportMargin();
        
        // 差分強調表示の色をカスタマイズするCSS
        const customStyles = document.createElement('style');
        customStyles.textContent = `
          .CodeMirror-merge-r-chunk { 
            background-color: rgba(200, 230, 201, 0.8) !important; 
          }
          .CodeMirror-merge-l-chunk { 
            background-color: rgba(255, 205, 210, 0.8) !important; 
          }
          .CodeMirror-merge-r-deleted, .CodeMirror-merge-l-deleted {
            background-color: rgba(255, 205, 210, 0.8) !important;
          }
          .CodeMirror-merge-r-inserted, .CodeMirror-merge-l-inserted {
            background-color: rgba(200, 230, 201, 0.8) !important;
          }
        `;
        document.head.appendChild(customStyles);
        
        // MergeViewのオプション
        const options = {
          value: rightText,
          origLeft: leftText,
          orig: null,
          lineNumbers: true,
          mode: language,
          highlightDifferences: true,
          connect: true,
          collapseIdentical: false,
          allowEditingOriginals: true,
          theme: theme,
          indentUnit: indentSize,
          tabSize: indentSize,
          lineWrapping: lineWrapping,
          matchBrackets: true,
          autoCloseBrackets: true,
          styleActiveLine: true,
          scrollbarStyle: 'simple',
          foldGutter: true,
          viewportMargin: viewportMargin,
          gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
          extraKeys: {
            'Tab': (cm) => {
              if (cm.somethingSelected()) {
                cm.indentSelection('add');
              } else {
                cm.replaceSelection(' '.repeat(indentSize), 'end');
              }
            },
            'Ctrl-/': (cm) => cm.toggleComment(),
            'Ctrl-F': 'findPersistent',
            'F3': 'findNext',
            'Shift-F3': 'findPrev',
            'Ctrl-G': 'jumpToLine',
            'Alt-F': 'fold',
            'Alt-U': 'unfold',
            'Alt-Down': () => gotoNextDiff(),
            'Alt-Up': () => gotoPrevDiff()
          }
        };
        
        // MergeViewの作成
        mergeViewRef.current = CodeMirror.MergeView(mergeViewContainerRef.current, options);
        
        // エディタのインスタンスを取得
        const leftEditor = mergeViewRef.current.leftOriginal();
        const rightEditor = mergeViewRef.current.editor();
        
        // フォントサイズの設定
        leftEditor.getWrapperElement().style.fontSize = `${fontSize}px`;
        rightEditor.getWrapperElement().style.fontSize = `${fontSize}px`;
        
        // デバッグモードの適用
        if (debugMode) {
          leftEditor.getWrapperElement().classList.add('debug-highlight');
          rightEditor.getWrapperElement().classList.add('debug-highlight');
        } else {
          leftEditor.getWrapperElement().classList.remove('debug-highlight');
          rightEditor.getWrapperElement().classList.remove('debug-highlight');
        }
        
        // エディタの変更イベント
        leftEditor.on('change', () => {
          setLeftText(leftEditor.getValue());
          
          // 変更前のスクロール位置を保存
          const leftScrollTop = leftEditor.getScrollInfo().top;
          const rightScrollTop = rightEditor.getScrollInfo().top;
          
          // 変更時は少し遅延させてから差分を更新
          if (scrollAnimationFrameRef.current) {
            cancelAnimationFrame(scrollAnimationFrameRef.current);
          }
          
          scrollAnimationFrameRef.current = requestAnimationFrame(() => {
            createMinimapMarkers();
            
            // スクロール位置を復元
            leftEditor.scrollTo(null, leftScrollTop);
            rightEditor.scrollTo(null, rightScrollTop);
          });
        });
        
        rightEditor.on('change', () => {
          setRightText(rightEditor.getValue());
          
          // 変更前のスクロール位置を保存
          const leftScrollTop = leftEditor.getScrollInfo().top;
          const rightScrollTop = rightEditor.getScrollInfo().top;
          
          // 変更時は少し遅延させてから差分を更新
          if (scrollAnimationFrameRef.current) {
            cancelAnimationFrame(scrollAnimationFrameRef.current);
          }
          
          scrollAnimationFrameRef.current = requestAnimationFrame(() => {
            createMinimapMarkers();
            
            // スクロール位置を復元
            leftEditor.scrollTo(null, leftScrollTop);
            rightEditor.scrollTo(null, rightScrollTop);
          });
        });
        
        // カーソル位置の更新
        rightEditor.on('cursorActivity', () => {
          const cursor = rightEditor.getCursor();
          setCursorPosition({ line: cursor.line + 1, ch: cursor.ch + 1 });
        });
        
        // スクロールイベント
        leftEditor.on('scroll', () => {
          if (minimapRef.current && !minimapDraggingRef.current) {
            if (scrollAnimationFrameRef.current) {
              cancelAnimationFrame(scrollAnimationFrameRef.current);
            }
            
            scrollAnimationFrameRef.current = requestAnimationFrame(() => {
              // スクロール中フラグを設定
              isScrollingRef.current = true;
              
              // スクロール時はビューポートの位置のみを更新
              updateViewportPosition(leftEditor.getScrollInfo());
              
              // スクロール完了後にフラグをリセット（非常に短い遅延）
              setTimeout(() => {
                isScrollingRef.current = false;
              }, 50);
            });
          }
        });
        
        rightEditor.on('scroll', () => {
          if (minimapRef.current && !minimapDraggingRef.current) {
            if (scrollAnimationFrameRef.current) {
              cancelAnimationFrame(scrollAnimationFrameRef.current);
            }
            
            scrollAnimationFrameRef.current = requestAnimationFrame(() => {
              // スクロール中フラグを設定
              isScrollingRef.current = true;
              
              // スクロール時はビューポートの位置のみを更新
              updateViewportPosition(rightEditor.getScrollInfo());
              
              // スクロール完了後にフラグをリセット（非常に短い遅延）
              setTimeout(() => {
                isScrollingRef.current = false;
              }, 50);
            });
          }
        });
        
        // パネル比率の適用
        if (mergeViewRef.current.wrap) {
          const container = mergeViewRef.current.wrap;
          const leftPane = container.querySelector('.CodeMirror-merge-pane');
          const rightPane = container.querySelector('.CodeMirror-merge-pane-rightmost');
          const gap = container.querySelector('.CodeMirror-merge-gap');
          
          if (leftPane && rightPane && gap) {
            // 分割比率の適用
            leftPane.style.width = `${splitRatio * 100 - 3}%`;
            rightPane.style.width = `${(1 - splitRatio) * 100 - 3}%`;
            gap.style.width = '6%';
            
            // エディタのリフレッシュ
            leftEditor.refresh();
            rightEditor.refresh();
            
            // スプリッター位置の更新
            if (resizerRef.current) {
              resizerRef.current.style.left = `${splitRatio * 100}%`;
            }
          }
        }
        
        // push to left/rightボタンクリック時のスクロール位置保持機能を追加
        fixCopyScroll();
        
        // 少し遅延させて差分マーカーを作成（初期化が確実に終わってから）
        setTimeout(() => {
          createMinimapMarkers();
        }, 100);
        
      }, [
        leftText, rightText, language, theme, indentSize, lineWrapping, fontSize, debugMode, 
        splitRatio, calculateViewportMargin, fixCopyScroll, gotoNextDiff, gotoPrevDiff,
        updateViewportPosition, createMinimapMarkers
      ]);
      
      // 行の折り返しの切り替え
      const toggleLineWrapping = useCallback(() => {
        setLineWrapping(!lineWrapping);
      }, [lineWrapping]);
      
      // 各種テーマの切り替え
      const toggleTheme = useCallback(() => {
        const themes = ['default', 'monokai', 'material', 'solarized'];
        const currentIndex = themes.indexOf(theme);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
      }, [theme]);
      
      // ダークモードの切り替え
      const toggleDarkMode = useCallback(() => {
        const newDarkMode = !darkMode;
        setDarkMode(newDarkMode);
        
        // ダークモード連動でテーマも変更
        if (newDarkMode && theme === 'default') {
          setTheme('monokai');
        } else if (!newDarkMode && theme === 'monokai') {
          setTheme('default');
        }
      }, [darkMode, theme]);
      
      // フォントサイズの変更
      const changeFontSize = useCallback((delta) => {
        const newSize = Math.max(10, Math.min(24, fontSize + delta));
        setFontSize(newSize);
        
        if (mergeViewRef.current) {
          const leftEditor = mergeViewRef.current.leftOriginal();
          const rightEditor = mergeViewRef.current.editor();
          
          if (leftEditor && rightEditor) {
            leftEditor.getWrapperElement().style.fontSize = `${newSize}px`;
            rightEditor.getWrapperElement().style.fontSize = `${newSize}px`;
            
            // エディタの再描画
            leftEditor.refresh();
            rightEditor.refresh();
          }
        }
      }, [fontSize]);
      
      // エディタの言語変更
      const handleLanguageChange = useCallback((e) => {
        setLanguage(e.target.value);
      }, []);
      
      // インデントサイズの変更
      const handleIndentSizeChange = useCallback((e) => {
        setIndentSize(parseInt(e.target.value));
      }, []);
      
      // 検索機能の呼び出し
      const openSearch = useCallback(() => {
        if (mergeViewRef.current) {
          const editor = mergeViewRef.current.editor();
          if (editor) {
            editor.execCommand('findPersistent');
          }
        }
      }, []);
      
      // パネルの分割比率を適用
      const applySplitRatio = useCallback(() => {
        if (!mergeViewRef.current || !mergeViewRef.current.wrap) return;
        
        const container = mergeViewRef.current.wrap;
        const leftPane = container.querySelector('.CodeMirror-merge-pane');
        const rightPane = container.querySelector('.CodeMirror-merge-pane-rightmost');
        const gap = container.querySelector('.CodeMirror-merge-gap');
        
        if (!leftPane || !rightPane || !gap) return;
        
        // 分割比率の適用
        leftPane.style.width = `${splitRatio * 100 - 3}%`;
        rightPane.style.width = `${(1 - splitRatio) * 100 - 3}%`;
        gap.style.width = '6%';
        
        // エディタのリフレッシュ
        mergeViewRef.current.leftOriginal().refresh();
        mergeViewRef.current.editor().refresh();
        
        // スプリッター位置の更新
        if (resizerRef.current) {
          resizerRef.current.style.left = `${splitRatio * 100}%`;
        }
      }, [splitRatio]);
      
      // スプリッターのドラッグ開始
      const startResize = useCallback((e) => {
        if (!mergeViewContainerRef.current) return;
        
        startXRef.current = e.clientX;
        startWidthRef.current = mergeViewContainerRef.current.offsetWidth;
        
        const handleMouseMove = (e) => {
          if (!mergeViewContainerRef.current) return;
          
          const dx = e.clientX - startXRef.current;
          const containerWidth = startWidthRef.current;
          
          // 新しい分割比率の計算（範囲を制限）
          const newRatio = Math.min(0.8, Math.max(0.2, splitRatio + dx / containerWidth));
          setSplitRatio(newRatio);
          applySplitRatio();
        };
        
        const handleMouseUp = () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          
          if (resizerRef.current) {
            resizerRef.current.classList.remove('active');
          }
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        if (resizerRef.current) {
          resizerRef.current.classList.add('active');
        }
      }, [splitRatio, applySplitRatio]);
      
      // ファイル選択処理
      const handleFileSelect = useCallback((file, side) => {
        if (!file) return;
        
        setLoading(true);
        
        // ファイル拡張子からコード言語を判別
        const fileName = file.name;
        const extension = fileName.split('.').pop().toLowerCase();
        
        // 言語の自動判別
        let detectedLanguage = language;
        if (['js', 'jsx', 'json'].includes(extension)) {
          detectedLanguage = 'javascript';
        } else if (['py'].includes(extension)) {
          detectedLanguage = 'python';
        } else if (['html', 'htm', 'xml', 'svg'].includes(extension)) {
          detectedLanguage = 'xml';
        } else if (['css'].includes(extension)) {
          detectedLanguage = 'css';
        }
        
        // 言語が変わった場合は更新
        if (detectedLanguage !== language) {
          setLanguage(detectedLanguage);
        }
        
        // ファイル読み込み
        const reader = new FileReader();
        reader.onload = (e) => {
          const text = e.target.result;
          
          // スクロール位置をリセットしないように一度スクロールフラグを立てる
          isScrollingRef.current = true;
          
          if (side === 'left') {
            setLeftText(text);
            setLeftActiveFile(fileName);
            
            // 左側エディタを直接更新
            if (mergeViewRef.current?.leftOriginal()) {
              const leftEditor = mergeViewRef.current.leftOriginal();
              const oldScrollTop = leftEditor.getScrollInfo().top;
              
              leftEditor.setValue(text);
              
              // 値設定後にスクロール位置を維持
              setTimeout(() => {
                leftEditor.scrollTo(null, oldScrollTop);
              }, 0);
            }
          } else {
            setRightText(text);
            setRightActiveFile(fileName);
            
            // 右側エディタを直接更新
            if (mergeViewRef.current?.editor()) {
              const rightEditor = mergeViewRef.current.editor();
              const oldScrollTop = rightEditor.getScrollInfo().top;
              
              rightEditor.setValue(text);
              
              // 値設定後にスクロール位置を維持
              setTimeout(() => {
                rightEditor.scrollTo(null, oldScrollTop);
              }, 0);
            }
          }
          
          setLoading(false);
          
          // ファイル読み込み後に差分解析を実行
          setTimeout(() => {
            createMinimapMarkers();
            isScrollingRef.current = false;
          }, 100);
        };
        
        reader.onerror = () => {
          console.error('ファイル読み込みエラー');
          setLoading(false);
          isScrollingRef.current = false;
        };
        
        reader.readAsText(file);
      }, [language, createMinimapMarkers]);
      
      // 差分項目をクリックしたときのジャンプ処理
      const handleSummaryItemClick = useCallback((diffItem) => {
        if (!mergeViewRef.current) return;
        
        // 共通のジャンプ関数を使用
        jumpToDiff(diffItem);
        
        // この差分のインデックスを探す
        const index = diffListRef.current.findIndex(diff => 
          diff.side === diffItem.side && diff.startLine === diffItem.startLine
        );
        
        if (index !== -1) {
          setCurrentDiffIndex(index);
          currentDiffIndexRef.current = index;
          updateActiveMarker(index);
        }
      }, [jumpToDiff, updateActiveMarker]);
      
      // クリップボードからペースト（左側）
      const pasteFromClipboardLeft = useCallback(async () => {
        try {
          const text = await navigator.clipboard.readText();
          setLeftText(text);
          setLeftActiveFile('クリップボードから貼り付け');
          
          // 左側エディタを直接更新
          if (mergeViewRef.current?.leftOriginal()) {
            mergeViewRef.current.leftOriginal().setValue(text);
          }
          
          // 貼り付け後に差分解析を実行
          setTimeout(() => {
            createMinimapMarkers();
          }, 100);
        } catch (e) {
          console.error('クリップボードからの読み込みエラー:', e);
          alert('クリップボードからの読み込みに失敗しました。ブラウザの権限設定を確認してください。');
        }
      }, [createMinimapMarkers]);
      
      // クリップボードからペースト（右側）
      const pasteFromClipboardRight = useCallback(async () => {
        try {
          const text = await navigator.clipboard.readText();
          setRightText(text);
          setRightActiveFile('クリップボードから貼り付け');
          
          // 右側エディタを直接更新
          if (mergeViewRef.current?.editor()) {
            mergeViewRef.current.editor().setValue(text);
          }
          
          // 貼り付け後に差分解析を実行
          setTimeout(() => {
            createMinimapMarkers();
          }, 100);
        } catch (e) {
          console.error('クリップボードからの読み込みエラー:', e);
          alert('クリップボードからの読み込みに失敗しました。ブラウザの権限設定を確認してください。');
        }
      }, [createMinimapMarkers]);
      
      // ドラッグ&ドロップエリアのイベント処理
      const handleDragOver = useCallback((e, side) => {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.add('dragging');
      }, []);
      
      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('dragging');
      }, []);
      
      const handleDrop = useCallback((e, side) => {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('dragging');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          handleFileSelect(files[0], side);
        }
      }, [handleFileSelect]);
      
      // デバッグモードの切り替え（隠し機能）
      const toggleDebugMode = useCallback(() => {
        setDebugMode(!debugMode);
        
        if (mergeViewRef.current) {
          const leftEditor = mergeViewRef.current.leftOriginal();
          const rightEditor = mergeViewRef.current.editor();
          
          if (leftEditor && rightEditor) {
            if (!debugMode) {
              leftEditor.getWrapperElement().classList.add('debug-highlight');
              rightEditor.getWrapperElement().classList.add('debug-highlight');
            } else {
              leftEditor.getWrapperElement().classList.remove('debug-highlight');
              rightEditor.getWrapperElement().classList.remove('debug-highlight');
            }
          }
        }
      }, [debugMode]);
      
      useEffect(() => {
        // MergeViewの初期化処理
        initMergeView();
        
        // MergeView初期化後に必ず差分マーカーを作成
        const initTimer = setTimeout(() => {
          createMinimapMarkers();
        }, 150);
        
        return () => {
          clearTimeout(initTimer);
        };
      }, [
        leftText, rightText, language, theme, indentSize, lineWrapping, fontSize, debugMode, 
        splitRatio, initMergeView, createMinimapMarkers
      ]);
      
      // エディタ内容が変わったときに再度差分マーカーを作成
      useEffect(() => {
        if (mergeViewRef.current) {
          createMinimapMarkers();
        }
      }, [leftText, rightText, createMinimapMarkers]);
      
      // ミニマップのイベント設定
      useEffect(() => {
        if (minimapRef.current) {
          minimapRef.current.addEventListener('click', handleMinimapClick);
          minimapRef.current.addEventListener('wheel', handleMinimapWheel, { passive: false });
          
          return () => {
            minimapRef.current.removeEventListener('click', handleMinimapClick);
            minimapRef.current.removeEventListener('wheel', handleMinimapWheel);
          };
        }
      }, [handleMinimapClick, handleMinimapWheel]);
      
      // グローバルドラッグ&ドロップ処理
      useEffect(() => {
        const dropOverlay = document.querySelector('.drop-overlay');
        
        const handleGlobalDragOver = (e) => {
          e.preventDefault();
          dropOverlay.classList.add('visible');
        };
        
        const handleGlobalDragLeave = (e) => {
          e.preventDefault();
          dropOverlay.classList.remove('visible');
        };
        
        const handleGlobalDrop = (e) => {
          e.preventDefault();
          dropOverlay.classList.remove('visible');
          
          const files = e.dataTransfer.files;
          if (files.length === 0) return;
          
          // 複数ファイルの処理
          if (files.length === 1) {
            handleFileSelect(files[0], 'right');
          } else if (files.length >= 2) {
            handleFileSelect(files[0], 'left');
            handleFileSelect(files[1], 'right');
          }
        };
        
        document.addEventListener('dragover', handleGlobalDragOver);
        document.addEventListener('dragleave', handleGlobalDragLeave);
        document.addEventListener('drop', handleGlobalDrop);
        
        return () => {
          document.removeEventListener('dragover', handleGlobalDragOver);
          document.removeEventListener('dragleave', handleGlobalDragLeave);
          document.removeEventListener('drop', handleGlobalDrop);
        };
      }, [handleFileSelect]);
      
      // キーボードショートカット
      useEffect(() => {
        const handleKeyDown = (e) => {
          // デバッグモード切替: Ctrl+Shift+D
          if (e.ctrlKey && e.shiftKey && e.key === 'D') {
            toggleDebugMode();
          }
        };
        
        document.addEventListener('keydown', handleKeyDown);
        
        return () => {
          document.removeEventListener('keydown', handleKeyDown);
        };
      }, [toggleDebugMode]);
      
      // ウィンドウリサイズ時の処理
      useEffect(() => {
        const handleResize = () => {
          if (scrollAnimationFrameRef.current) {
            cancelAnimationFrame(scrollAnimationFrameRef.current);
          }
          
          scrollAnimationFrameRef.current = requestAnimationFrame(() => {
            if (mergeViewRef.current) {
              mergeViewRef.current.leftOriginal().refresh();
              mergeViewRef.current.editor().refresh();
              createMinimapMarkers();
            }
          });
        };
        
        window.addEventListener('resize', handleResize);
        
        return () => {
          window.removeEventListener('resize', handleResize);
          if (scrollAnimationFrameRef.current) {
            cancelAnimationFrame(scrollAnimationFrameRef.current);
          }
        };
      }, [createMinimapMarkers]);
      
      return (
        <div className={`app-container ${debugMode ? 'debug-mode' : ''}`}>
          <div className="header">
            <h1>差分表示ツール</h1>
            {debugMode && <div style={{color: 'red'}}>デバッグモード</div>}
          </div>
          
          <div className="toolbar">
            {/* ファイル入力部分 */}
            <div className="toolbar-group">
              <div className="file-input-container">
                <div 
                  className="file-drop-area"
                  onDragOver={(e) => handleDragOver(e, 'left')}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) => handleDrop(e, 'left')}
                  onClick={() => document.getElementById('left-file-input').click()}
                >
                  {leftActiveFile ? leftActiveFile : 'ファイルをドロップまたはクリック (左)'}
                  <input 
                    id="left-file-input"
                    type="file" 
                    onChange={(e) => e.target.files[0] && handleFileSelect(e.target.files[0], 'left')} 
                    style={{display: 'none'}}
                  />
                </div>
                <button onClick={pasteFromClipboardLeft} title="クリップボードから左側にペースト">
                  左に貼付
                </button>
              </div>
              
              <div className="file-input-container">
                <div 
                  className="file-drop-area"
                  onDragOver={(e) => handleDragOver(e, 'right')}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) => handleDrop(e, 'right')}
                  onClick={() => document.getElementById('right-file-input').click()}
                >
                  {rightActiveFile ? rightActiveFile : 'ファイルをドロップまたはクリック (右)'}
                  <input 
                    id="right-file-input"
                    type="file" 
                    onChange={(e) => e.target.files[0] && handleFileSelect(e.target.files[0], 'right')} 
                    style={{display: 'none'}}
                  />
                </div>
                <button onClick={pasteFromClipboardRight} title="クリップボードから右側にペースト">
                  右に貼付
                </button>
              </div>
            </div>
            
            {/* 言語・インデント設定 */}
            <div className="toolbar-group">
              <select value={language} onChange={handleLanguageChange}>
                <option value="javascript">JavaScript</option>
                <option value="python">Python</option>
                <option value="xml">HTML/XML</option>
                <option value="css">CSS</option>
              </select>
              
              <select value={indentSize} onChange={handleIndentSizeChange}>
                <option value="2">2スペース</option>
                <option value="4">4スペース</option>
                <option value="8">8スペース</option>
              </select>
            </div>
            
            {/* 差分ナビゲーション */}
            <div className="toolbar-group diff-nav-buttons">
              <button 
                className={`icon-button ${diffListRef.current.length === 0 ? 'disabled' : ''}`}
                onClick={gotoPrevDiff} 
                title="前の差分に移動 (Alt+↑)"
                disabled={diffListRef.current.length === 0}
              >
                ↑
                {currentDiffIndex >= 0 && diffCount > 0 && (
                  <span className="current-pos-badge">{currentDiffIndex + 1}</span>
                )}
              </button>
              
              <button 
                className={`icon-button ${diffListRef.current.length === 0 ? 'disabled' : ''}`}
                onClick={gotoNextDiff} 
                title="次の差分に移動 (Alt+↓)"
                disabled={diffListRef.current.length === 0}
              >
                ↓
                {diffCount > 0 && (
                  <span className="diff-count-badge">{diffCount}</span>
                )}
              </button>
            </div>
            
            {/* 表示設定 */}
            <div className="toolbar-group">
              <button 
                className={`icon-button ${lineWrapping ? 'active' : ''}`}
                onClick={toggleLineWrapping} 
                title="行の折り返し"
              >
                ↩
              </button>
              
              <button 
                className="icon-button"
                onClick={() => changeFontSize(-1)} 
                title="フォントサイズを小さく"
              >
                A-
              </button>
              
              <button 
                className="icon-button"
                onClick={() => changeFontSize(1)} 
                title="フォントサイズを大きく"
              >
                A+
              </button>
              
              <button 
                className="icon-button"
                onClick={toggleTheme} 
                title="エディタテーマを変更"
              >
                {theme === 'default' ? '🎨' : '🌈'}
              </button>
              
              <button 
                className={`icon-button ${darkMode ? 'active' : ''}`}
                onClick={toggleDarkMode} 
                title="ダークモード切替"
              >
                {darkMode ? '☀️' : '🌙'}
              </button>
            </div>
            
            {/* ツール */}
            <div className="toolbar-group">
              <button 
                className="icon-button"
                onClick={openSearch} 
                title="検索 (Ctrl+F)"
              >
                🔍
              </button>
              
              <button 
                className={`icon-button ${showDiffSummary ? 'active' : ''}`}
                onClick={() => setShowDiffSummary(!showDiffSummary)} 
                title="差分サマリーの表示/非表示"
              >
                📋
              </button>
              
              <button 
                className="icon-button"
                onClick={() => setSettingsVisible(!settingsVisible)} 
                title="設定"
              >
                ⚙️
              </button>
              
              {debugMode && (
                <button 
                  className={`icon-button`}
                  onClick={() => createMinimapMarkers()} 
                  title="ミニマップ強制更新"
                >
                  🔄
                </button>
              )}
            </div>
          </div>
          
          {/* オプション: 差分サマリー */}
          {showDiffSummary && (
            <div className="diff-summary">
              <div className="diff-summary-title">
                差分サマリー ({diffCount}件)
                {currentDiffIndex >= 0 && diffCount > 0 && (
                  <span style={{marginLeft: '10px'}}>
                    現在: {currentDiffIndex + 1} / {diffCount}
                  </span>
                )}
              </div>
              {diffCount > 0 ? (
                <div>
                  {debugMode && <button onClick={createMinimapMarkers}>差分情報を更新</button>}
                  <div>差分情報がミニマップに表示されています</div>
                  <div>Alt+↑/↓ または ↑/↓ボタンで差分間を移動できます</div>
                  
                  {/* 差分リスト */}
                  {diffListRef.current.slice(0, 5).map((diff, i) => (
                    <div 
                      key={i} 
                      className={`diff-item ${currentDiffIndex === i ? 'active' : ''}`}
                      onClick={() => handleSummaryItemClick(diff)}
                      style={{
                        backgroundColor: currentDiffIndex === i ? '#e8f0fe' : 'transparent',
                      }}
                    >
                      <div 
                        className={`diff-marker ${diff.side === 'left' ? 'deletion' : 'addition'}`}
                      ></div>
                      <div className="diff-location">
                        {diff.side === 'left' ? '左' : '右'}: 行 {diff.startLine + 1}
                      </div>
                    </div>
                  ))}
                  {diffListRef.current.length > 5 && (
                    <div style={{fontSize: '12px', marginTop: '5px', color: '#666'}}>
                      他 {diffListRef.current.length - 5} 件の差分...
                    </div>
                  )}
                </div>
              ) : (
                <div>差分はありません</div>
              )}
            </div>
          )}
          
          {/* メインコンテンツ */}
          <div className="main-content">
            <div ref={minimapRef} className="diff-minimap"></div>
            
            <div 
              ref={mergeViewContainerRef} 
              className="merge-view-container"
            ></div>
            
            <div 
              ref={resizerRef}
              className="resizer"
              style={{ left: `${splitRatio * 100}%` }}
              onMouseDown={startResize}
            ></div>
          </div>
          
          {/* 設定パネル */}
          <div className={`settings-panel ${settingsVisible ? 'visible' : ''}`}>
            <div className="settings-group">
              <div className="settings-title">エディタ設定</div>
              <div className="settings-row">
                <div className="settings-label">フォントサイズ</div>
                <input 
                  type="range" 
                  min="10" 
                  max="24" 
                  value={fontSize} 
                  onChange={(e) => setFontSize(Number(e.target.value))} 
                />
                <span>{fontSize}px</span>
              </div>
              <div className="settings-row">
                <div className="settings-label">行の折り返し</div>
                <input 
                  type="checkbox" 
                  checked={lineWrapping} 
                  onChange={() => setLineWrapping(!lineWrapping)} 
                />
              </div>
              <div className="settings-row">
                <div className="settings-label">差分サマリー表示</div>
                <input 
                  type="checkbox" 
                  checked={showDiffSummary}
                  onChange={() => setShowDiffSummary(!showDiffSummary)} 
                />
              </div>
            </div>
            
            <div className="settings-group">
              <div className="settings-title">テーマ設定</div>
              <div className="settings-row">
                <div className="settings-label">エディタテーマ</div>
                <select value={theme} onChange={(e) => setTheme(e.target.value)}>
                  <option value="default">デフォルト</option>
                  <option value="monokai">Monokai</option>
                  <option value="material">Material</option>
                  <option value="solarized">Solarized</option>
                </select>
              </div>
              <div className="settings-row">
                <div className="settings-label">ダークモード</div>
                <input 
                  type="checkbox" 
                  checked={darkMode} 
                  onChange={() => setDarkMode(!darkMode)} 
                />
              </div>
              {debugMode && (
                <div className="settings-row">
                  <div className="settings-label">デバッグモード</div>
                  <input 
                    type="checkbox" 
                    checked={debugMode}
                    onChange={() => toggleDebugMode()} 
                  />
                </div>
              )}
            </div>
            
            <div className="settings-buttons">
              <button onClick={() => setSettingsVisible(false)}>閉じる</button>
              <button onClick={saveSettings}>保存</button>
            </div>
          </div>
          
          {/* ショートカット情報 */}
          <div className="shortcuts-info">
            <div className="shortcut-item">
              <span className="shortcut-key">Alt+↓</span>
              <span>次の差分</span>
            </div>
            <div className="shortcut-item">
              <span className="shortcut-key">Alt+↑</span>
              <span>前の差分</span>
            </div>
            <div className="shortcut-item">
              <span className="shortcut-key">Ctrl+F</span>
              <span>検索</span>
            </div>
            <div className="shortcut-item">
              <span className="shortcut-key">Tab</span>
              <span>{indentSize}スペース挿入</span>
            </div>
            <div className="shortcut-item">
              <span className="shortcut-key">Ctrl+/</span>
              <span>コメントトグル</span>
            </div>
            {debugMode && (
              <div className="shortcut-item">
                <span className="shortcut-key">Ctrl+Shift+D</span>
                <span>デバッグモード切替</span>
              </div>
            )}
          </div>
          
          {/* ステータスバー */}
          <div className="status-bar">
            <div>
              {loading ? (
                <>
                  <span className="spinner"></span>
                  <span>読み込み中...</span>
                </>
              ) : (
                <>
                  {diffCount > 0 
                    ? `差分: ${diffCount}箇所 ${currentDiffIndex >= 0 ? `(現在: ${currentDiffIndex + 1}/${diffCount})` : ''}` 
                    : '差分なし'}
                </>
              )}
              
              <span className="cursor-info">
                行:{cursorPosition.line} 列:{cursorPosition.ch}
              </span>
            </div>
            <div>{language} | インデント: {indentSize}スペース | テーマ: {theme} | フォントサイズ: {fontSize}px</div>
          </div>
        </div>
      );
    }
    
    ReactDOM.render(<DiffApp />, document.getElementById('app'));
  </script>
</body>
</html>